# Регулярные выражения  
*Примечание: это почти полная копия статьи про регулярные выражения, просто мне она показалась довольно интересной и полезной, поэтому я не стал ее резать*
Регулярные выражения (их еще называют regexp, или regex) — это механизм для поиска и замены текста. В строке, файле, нескольких файлах... Их используют разработчики в коде приложения, тестировщики в автотестах, да просто при работе в командной строке!

Чем это лучше простого поиска? Тем, что позволяет задать шаблон.

Например, на вход приходит дата рождения в формате ДД.ММ.ГГГГГ. Вам надо передать ее дальше, но уже в формате ГГГГ-ММ-ДД. Как это сделать с помощью простого поиска? Вы же не знаете заранее, какая именно дата будет.  
Области применения regex разнообразны, от валидации до парсинга/замены строк, передачи данных в другие форматы и Web Scraping’а.

Одна из любопытных особенностей регулярных выражений в их универсальности, стоит вам выучить синтаксис, и вы сможете применять их в любом (почти) языке программирования (JavaScript, Java, VB, C #, C / C++, Python, Perl, Ruby, Delphi, R, Tcl, и многих других). Небольшие отличия касаются только наиболее продвинутых функций и версий синтаксиса, поддерживаемых движком.

Давайте начнём с нескольких примеров.    

# Основы
## Якоря — ^ и $  
    ^Привет        соответствует строке, начинающейся с Привет 
    пока$          соответствует строке, заканчивающейся на пока  
    ^Привет пока$  точное совпадение (начинается и заканчивается как Привет пока)  
    воробушки      соответствует любой строке, в которой есть текст воробушки  
[тест](https://regex101.com/r/cO8lqs/2)  

## Квантификаторы — * + ? и {}
    abc*       соответствует строке, в которой после ab следует 0 или более символов
    abc+       соответствует строке, в которой после ab следует один или более символов c
    abc?       соответствует строке, в которой после ab следует 0 или один символ c
    abc{2}     соответствует строке, в которой после ab следует 2 символа c
    abc{2,}    соответствует строке, в которой после ab следует 2 или более символов c
    abc{2,5}   соответствует строке, в которой после ab следует от 2 до 5 символов c
    a(bc)*     соответствует строке, в которой после ab следует 0 или более последовательностей символов bc
    a(bc){2,5} соответствует строке, в которой после ab следует от 2 до 5 последовательностей символов bc  
[тест](https://regex101.com/r/cO8lqs/1)   

## Оператор ИЛИ — | или []
    a(b|c) соответствует строке, в которой после a следует b или c 
    a[bc]  как и в предыдущем примере
[тест](https://regex101.com/r/cO8lqs/3)     

## Символьные классы — \d \w \s и .
    \d соответствует одному символу, который является цифрой 
    \w соответствует слову (может состоять из букв, цифр и подчёркивания) 
    \s соответствует символу пробела (включая табуляцию и прерывание строки)
    . соответствует любому символу 
Используйте оператор `.` с осторожностью, так как зачастую класс или отрицаемый класс символов (который мы рассмотрим далее) быстрее и точнее.

У операторов `\d`, `\w` и `\s` также есть отрицания ― `\D`, `\W` и `\S` соответственно.

Например, оператор `\D` будет искать соответствия противоположенные `\d`.  
  
`\D` соответствует одному символу, который не является цифрой -> [тест](https://regex101.com/r/cO8lqs/6)  

Некоторые символы, например `^.[$()|*+?{\` , необходимо выделять обратным слешем `\`.  

`\$\d соответствует строке, в которой после символа $ следует одна цифра` -> [тест](https://regex101.com/r/cO8lqs/9)   

Непечатаемые символы также можно искать, например табуляцию `\t`, новую строку `\n`, возврат каретки `\r`.  

## Флаги  
Мы научились строить регулярные выражения, но забыли о фундаментальной концепции ― флагах.

Регулярное выражение, как правило, записывается в такой форме `/abc/`, где шаблон для сопоставления выделен двумя слешами `/`. В конце выражения, мы определяем значение флага (эти значения можно комбинировать):  
* g (global) ― не возвращает результат после первого совпадения, а продолжает поиск с конца предыдущего совпадения.
* m (multi line) ― с таким флагом, операторы `^` и `$` вызовут совпадение в начале и конце строки ввода (line), вместо строки целиком (string).
* i (insensitive) ― делает выражение регистронезависимым (например, /aBc/i соответствует AbC).  

# Средний уровень  

## Скобочные группы ― () 
`a(bc)       создаём группу со значением bc` -> [тест](https://regex101.com/r/cO8lqs/11)  
`a(?:bc)*    оперетор ?: отключает группу` -> [тест](https://regex101.com/r/cO8lqs/12)  
`a(?<foo>bc) так, мы можем присвоить имя группе` -> [тест](https://regex101.com/r/cO8lqs/17)  

Этот оператор очень полезен, когда нужно извлечь информацию из строк или данных, используя ваш любимый язык программирования. Любые множественные совпадения, по нескольким группам, будут представлены в виде классического массива: доступ к их значениям можно получить с помощью индекса из результатов сопоставления.

Если присвоить группам имена (используя `(?<foo>...)`), то можно получить их значения, используя результат сопоставления, как словарь, где ключами будут имена каждой группы.  

## Скобочные выражения ― []  
`[abc]       соответствует строке, которая содержит либо символ a или a b или a c` -> `такой же эффект от a|b|c` -> [тест](https://regex101.com/r/cO8lqs/7)  
`[a-c]       то же, что и выше`  
`[a-fA-F0–9] строка, представляющая одну шестнадцатеричную цифру без учёта регистра` -> [тест](https://regex101.com/r/cO8lqs/22)  
`[0–9]%      строка, содержащая символ от 0 до 9 перед знаком %`
`[^a-zA-Z]   строка, которая не имеет буквы от a до z или от A до Z. В этом случае ^ используется как отрицание в выражении` -> [тест](https://regex101.com/r/cO8lqs/10)  

Помните, что внутри скобочных выражений все специальные символы (включая обратную косую черту \) теряют своё служебное значение, поэтому нам ненужно их экранировать.  

## Жадные и ленивые сопоставления  
Квантификаторы (` * + {}`) ― это «жадные» операторы, потому что они продолжают поиск соответствий, как можно глубже ― через весь текст.

Например, выражение `<.+>` соответствует `<div>simple div</div>` в `This is a <div> simple div</div> test`. Чтобы найти только тэг `div` ― можно использовать оператор `?`, сделав выражение «ленивым»:

`<.+?> соответствует любому символу, один или несколько раз найденному между < и >, расширяется по мере необходимости` -> [тест](https://regex101.com/r/cO8lqs/24)  
Обратите внимание, что хорошей практикой считается не использовать оператор `.` , в пользу более строгого выражения:

`<[^<>]+>`  соответствует любому символу, кроме `< или >`, один или более раз встречающемуся между `< и >` -> [тест](https://regex101.com/r/cO8lqs/23)  

# Продвинутый уровень  
## Границы слов ― \b и \B   

`\babc\b` выполняет поиск слова целиком -> [тест](https://regex101.com/r/cO8lqs/25)  

`\b` ― соответствует границе слова, наподобие якоря (он похож на `$` и `^`), где предыдущий символ ― словесный (например, `\w`), а следующий ― нет, либо наоборот, (например, это может быть начало строки или пробел).

`\B` ― соответствует несловообразующей границе. Соответствие не должно обнаруживаться на границе `\b`.  

`\Babc\B` соответствует, только если шаблон полностью окружён словами(символами) -> [тест](https://regex101.com/r/cO8lqs/26)  
Но к сожалению, если шаблон слова написан кириллицей, а его окружают латинские символы, то поиск не сработает и наоборот, если шаблон с латинскими буквами окружен Кириллицей, то тоже ничего не сработает.  
`\Babc\B` не найдет в таком `ненайдешьabcникогда`  
`\Bпоиск\B` не найдет в таком `i can'tпоискfind this word`  
## Обратные ссылки — \1  

`([abc])\1 \1 `         соответствует тексту из первой захватываемой группы -> [тест](https://regex101.com/r/cO8lqs/14)  
`([abc])([de])\2\1`     можно использовать `\2` (`\3`, `\4`, и т.д.) для определения порядкового номера захватываемой группы -> [тест](https://regex101.com/r/cO8lqs/15)  
`(?<foo>[abc])\k<foo>`  мы присвоили имя `foo` группе, и теперь ссылаемся на неё используя ― (`\k<foo>`). Результат, как и в первом выражении -> [тест](https://regex101.com/r/cO8lqs/16)  

**Вы можете использовать оператор отрицания !**

`d(?!r)` соответствует `d`, только если после этого нет `r`, но `r` не будет входить в соответствие выражения -> [тест](https://regex101.com/r/cO8lqs/20)  
`(?<!r)d` соответствует `d`, только если перед этим нет `r`, но `r` не будет входить в соответствие выражения -> [тест](https://regex101.com/r/cO8lqs/21)  

# Использование в Java  
Небольшой пример использование простых(можно и сложные, но мне было не к чему) регулярных выражений в java  

В данном случае я создал Map для хранения нужных мне шаблонов.
```Java
private final Map<String, String> PATTERNS_FOR_ANALYSIS = new HashMap<String, String>() {{  //Шаблоны для анализа
        // привет
        put("хай", "hello");
        put("привет", "hello");
        put("здорово", "hello");
        put("здравствуй", "hello");
        // кто ты
        put("кто\\s.*ты", "who");
        put("ты\\s.*кто", "who");
        // Как зовут
        put("как\\s.*зовут", "name");
        put("как\\s.*имя", "name");
        put("есть\\s.*имя", "name");
        put("какое\\s.*имя", "name");
        // Как дела
        put("как\\sоно", "howareyou");
        put("как\\s.*дела", "howareyou");
        put("как\\s.*жизнь", "howareyou");
        //Что я делаю
        put("зачем\\s+я\\s.*тут", "whatdoidoing");
        put("зачем\\s+я\\s.*здесь", "whatdoidoing");
        put("что\\s+я\\s.*делаю", "whatdoidoing");
        put("чем\\s+я\\s.*занимаюсь", "whatdoidoing");

        // Что делаешь
        put("зачем\\s.*тут", "whatdoyoudoing");
        put("зачем\\s.*здесь", "whatdoyoudoing");
        put("что\\s.*делаешь", "whatdoyoudoing");
        put("чем\\s.*занимаешься", "whatdoyoudoing");

        //Спасибо
        put("пасибо", "thanks");
        put("пасибки", "thanks");
        put("благодарю", "thanks");
        put("благодарен", "thanks");
        put("от души", "thanks");


        // whatdoyoulike
        put("что\\s.*нравится", "whatdoyoulike");
        put("что\\s.*любишь", "whatdoyoulike");
        // iamfeelling
        put("кажется", "iamfeelling");
        put("чувствую", "iamfeelling");
        put("испытываю", "iamfeelling");
        // Согласие
        put("^да", "yes");
        put("согласен", "yes");
        // Дата и время
        put("который\\s.*час", "whattime");
        put("сколько\\s.*время", "whattime");
        // Прощание
        put("прощай", "bye");
        put("увидимся", "bye");
        put("до\\s.*свидания", "bye");
        put("пока", "bye");

        //

        //Интернет запросы
            //Погода
        put("как.*погода", "wheather");
        put("курс валют", "curs");
            //Запросы в браузер
        put("найди", "search");
        put("найти", "search");
        put("поиск", "search");
        put("поищи", "search");

        //Простые мат операции
            //Умножение
        put("посчитай", "calculator");
        put("вычисли", "calculator");
        put("сколько\\s+будет", "calculator");

    }};
```

Далее нужно эти регулярные выражения обработать. Для этого нужны такие 2 класса как `Pattern` и `Matcher`.  
**Замечу, что специальные символы типа `\s` я ставлю как `\\s`, потому что `\` в java, да и как во многих других языках программирования является специальным символом, поэтому, чтобы с ним работать, нужно его экранировать с помощью еще одного `\`.**  
После нужно обработать наши шаблоны для поиска и начать искать.  
```Java
        //Теперь пробежимся по мапам и поищем нужную нам фразу
        for (Map.Entry<String, String> entry: PATTERNS_FOR_ANALYSIS.entrySet())
        {
			//Компилируем шаблон для поиска 
            pattern = Pattern.compile(entry.getKey());       
			
			//Теперь ищем по этому шаблону
            matcher = pattern.matcher(message);

			//если нашли такой совпадения по шаблону
            if (matcher.find())                
            {
                //Дата и время
                if (entry.getValue().equals("whattime"))        //Если запрос был на время
                {
                    say = getDate();                           //То возвращаем время
                    break;
                }
                //Погода
                if (entry.getValue().equals("wheather"))
                {
                    Internet weather = new Internet();
                    say = weather.weather_info();
                    break;
                }
                //Валюта
                if (entry.getValue().equals("curs"))
                {
                    Internet curs = new Internet();
                    say = curs.USD_info() + "\n" + curs.EUR_info();
                    break;
                }
                //Вычисления
                if (entry.getValue().equals("calculator"))
                {
                    calculator = new Calculator();
                    String buf = message.substring(matcher.end(), message.length());
                    try {
                        say = String.valueOf(calculator.result(buf));
                        break;
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                //Поисковый запрос
                if (entry.getValue().equals("search"))
                {
                    //Вырезаем сам поисковый запрос
                    String request = message.substring(matcher.end(), message.length());

                    Internet search = new Internet();

                    try {
                        search.search(request);
                        say = "Вот что удалось найти";

                        break;
                    } catch (URISyntaxException e) {
                        say = "Не получилось найти, прошу прощения :(";
                        break;
                    } catch (IOException e) {
                        say = "Что то пошло не так, сорян :(";
                        break;
                    }
                }
```

Как мы видим, вот эти 3 строки основные:  

    //Компилируем шаблон для поиска 
    pattern = Pattern.compile(entry.getKey());       
			
    //Теперь ищем по этому шаблону
    matcher = pattern.matcher(message);

	//если нашли такой совпадения по шаблону
    if (matcher.find())    
            
Мы скомпилировали регулярное выражение, потом произвели поиск, и сделали условие, если поиск произошел успешно, то можем выполнять действия, которые мы хотели            

## Заключение
Как вы могли убедиться, области применения регулярных выражений разнообразны. Я уверен, что вы сталкивались с похожими задачами в своей работе (хотя бы с одной из них), например такими:

Валидация данных (например, правильно ли заполнена строка time)
*   Сбор данных (особенно веб-скрапинг, поиск страниц, содержащих определённый набор слов в определённом порядке)
*   Обработка данных (преобразование сырых данных в нужный формат)
*   Парсинг (например, достать все GET параметры из URL или текст внутри скобок)
*   Замена строк (даже во время написания кода в IDE, можно, например преобразовать Java или C# класс в соответствующий JSON объект, заменить “;” на “,”, изменить размер букв, избегать объявление типа и т.д.)
*   Подсветка синтаксиса, переименование файла, анализ пакетов и многие другие задачи, где нужно работать со строками (где данные не должны быть текстовыми).
Перевод статьи Jonny Fox: [Regex tutorial — A quick cheatsheet by examples](https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285)  
Уже переведенная статья https://medium.com/nuances-of-programming/шпаргалка-по-регулярным-выражениям-в-примерах-53820a5f3435
