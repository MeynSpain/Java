# Регулярные выражения
Регулярные выражения (их еще называют regexp, или regex) — это механизм для поиска и замены текста. В строке, файле, нескольких файлах... Их используют разработчики в коде приложения, тестировщики в автотестах, да просто при работе в командной строке!

Чем это лучше простого поиска? Тем, что позволяет задать шаблон.

Например, на вход приходит дата рождения в формате ДД.ММ.ГГГГГ. Вам надо передать ее дальше, но уже в формате ГГГГ-ММ-ДД. Как это сделать с помощью простого поиска? Вы же не знаете заранее, какая именно дата будет.  
Области применения regex разнообразны, от валидации до парсинга/замены строк, передачи данных в другие форматы и Web Scraping’а.

Одна из любопытных особенностей регулярных выражений в их универсальности, стоит вам выучить синтаксис, и вы сможете применять их в любом (почти) языке программирования (JavaScript, Java, VB, C #, C / C++, Python, Perl, Ruby, Delphi, R, Tcl, и многих других). Небольшие отличия касаются только наиболее продвинутых функций и версий синтаксиса, поддерживаемых движком.

Давайте начнём с нескольких примеров.    

# Основы
## Якоря — ^ и $  
    ^Привет        соответствует строке, начинающейся с Привет 
    пока$          соответствует строке, заканчивающейся на пока  
    ^Привет пока$  точное совпадение (начинается и заканчивается как Привет пока)  
    воробушки      соответствует любой строке, в которой есть текст воробушки  
[тест](https://regex101.com/r/cO8lqs/2)  

## Квантификаторы — * + ? и {}
    abc*       соответствует строке, в которой после ab следует 0 или более символов
    abc+       соответствует строке, в которой после ab следует один или более символов c
    abc?       соответствует строке, в которой после ab следует 0 или один символ c
    abc{2}     соответствует строке, в которой после ab следует 2 символа c
    abc{2,}    соответствует строке, в которой после ab следует 2 или более символов c
    abc{2,5}   соответствует строке, в которой после ab следует от 2 до 5 символов c
    a(bc)*     соответствует строке, в которой после ab следует 0 или более последовательностей символов bc
    a(bc){2,5} соответствует строке, в которой после ab следует от 2 до 5 последовательностей символов bc  
[тест](https://regex101.com/r/cO8lqs/1)   

## Оператор ИЛИ — | или []
    a(b|c) соответствует строке, в которой после a следует b или c 
    a[bc]  как и в предыдущем примере
[тест](https://regex101.com/r/cO8lqs/3)     

## Символьные классы — \d \w \s и .
    \d соответствует одному символу, который является цифрой 
    \w соответствует слову (может состоять из букв, цифр и подчёркивания) 
    \s соответствует символу пробела (включая табуляцию и прерывание строки)
    . соответствует любому символу 
Используйте оператор `.` с осторожностью, так как зачастую класс или отрицаемый класс символов (который мы рассмотрим далее) быстрее и точнее.

У операторов `\d`, `\w` и `\s` также есть отрицания ― `\D`, `\W` и `\S` соответственно.

Например, оператор `\D` будет искать соответствия противоположенные `\d`.  
  
`\D` соответствует одному символу, который не является цифрой -> [тест](https://regex101.com/r/cO8lqs/6)  

Некоторые символы, например `^.[$()|*+?{\` , необходимо выделять обратным слешем `\`.  

`\$\d соответствует строке, в которой после символа $ следует одна цифра` -> [тест](https://regex101.com/r/cO8lqs/9)   

Непечатаемые символы также можно искать, например табуляцию `\t`, новую строку `\n`, возврат каретки `\r`.  

## Флаги  
Мы научились строить регулярные выражения, но забыли о фундаментальной концепции ― флагах.

Регулярное выражение, как правило, записывается в такой форме `/abc/`, где шаблон для сопоставления выделен двумя слешами `/`. В конце выражения, мы определяем значение флага (эти значения можно комбинировать):  
* g (global) ― не возвращает результат после первого совпадения, а продолжает поиск с конца предыдущего совпадения.
* m (multi line) ― с таким флагом, операторы `^` и `$` вызовут совпадение в начале и конце строки ввода (line), вместо строки целиком (string).
* i (insensitive) ― делает выражение регистронезависимым (например, /aBc/i соответствует AbC).  

# Средний уровень  

## Скобочные группы ― () 
`a(bc)       создаём группу со значением bc` -> [тест](https://regex101.com/r/cO8lqs/11)  
`a(?:bc)*    оперетор ?: отключает группу` -> [тест](https://regex101.com/r/cO8lqs/12)  
`a(?<foo>bc) так, мы можем присвоить имя группе` -> [тест](https://regex101.com/r/cO8lqs/17)  

Этот оператор очень полезен, когда нужно извлечь информацию из строк или данных, используя ваш любимый язык программирования. Любые множественные совпадения, по нескольким группам, будут представлены в виде классического массива: доступ к их значениям можно получить с помощью индекса из результатов сопоставления.

Если присвоить группам имена (используя `(?<foo>...)`), то можно получить их значения, используя результат сопоставления, как словарь, где ключами будут имена каждой группы.  

## Скобочные выражения ― []  
`[abc]       соответствует строке, которая содержит либо символ a или a b или a c` -> `такой же эффект от a|b|c` -> [тест](https://regex101.com/r/cO8lqs/7)  
`[a-c]       то же, что и выше`  
`[a-fA-F0–9] строка, представляющая одну шестнадцатеричную цифру без учёта регистра` -> [тест](https://regex101.com/r/cO8lqs/22)  
`[0–9]%      строка, содержащая символ от 0 до 9 перед знаком %`
`[^a-zA-Z]   строка, которая не имеет буквы от a до z или от A до Z. В этом случае ^ используется как отрицание в выражении` -> [тест](https://regex101.com/r/cO8lqs/10)  

Помните, что внутри скобочных выражений все специальные символы (включая обратную косую черту \) теряют своё служебное значение, поэтому нам ненужно их экранировать.  

## Жадные и ленивые сопоставления  
Квантификаторы (` * + {}`) ― это «жадные» операторы, потому что они продолжают поиск соответствий, как можно глубже ― через весь текст.

Например, выражение `<.+>` соответствует `<div>simple div</div>` в `This is a <div> simple div</div> test`. Чтобы найти только тэг `div` ― можно использовать оператор `?`, сделав выражение «ленивым»:

`<.+?> соответствует любому символу, один или несколько раз найденному между < и >, расширяется по мере необходимости` -> [тест](https://regex101.com/r/cO8lqs/24)  
Обратите внимание, что хорошей практикой считается не использовать оператор `.` , в пользу более строгого выражения:

`<[^<>]+>`  соответствует любому символу, кроме `< или >`, один или более раз встречающемуся между `< и >` -> [тест](https://regex101.com/r/cO8lqs/23)  

# Продвинутый уровень  
## Границы слов ― \b и \B   

`\babc\b` выполняет поиск слова целиком -> [тест](https://regex101.com/r/cO8lqs/25)  

`\b` ― соответствует границе слова, наподобие якоря (он похож на `$` и `^`), где предыдущий символ ― словесный (например, `\w`), а следующий ― нет, либо наоборот, (например, это может быть начало строки или пробел).

`\B` ― соответствует несловообразующей границе. Соответствие не должно обнаруживаться на границе `\b`.  

`\Babc\B` соответствует, только если шаблон полностью окружён словами(символами) -> [тест](https://regex101.com/r/cO8lqs/26)  
Но к сожалению, если шаблон слова написан кириллицей, а его окружают латинские символы, то поиск не сработает и наоборот, если шаблон с латинскими буквами окружен Кириллицей, то тоже ничего не сработает.  
`\Babc\B` не найдет в таком `ненайдешьabcникогда`  
`\Bпоиск\B` не найдет в таком `i can'tпоискfind this word`  
## Обратные ссылки — \1
